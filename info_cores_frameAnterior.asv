%Esta funcão é usada somente dentro do algoritmo de associação no momento
%em que se vai calcular a distância dentro de um espaço de cores. Para que
%isso aconteça, deve-se antes, calcular o valor da cor atual (média das
%cores dos pixeis.

%OBS:
%tol = threshrold na track.m, que serve para a subtração de fundo;
%Imback = wbackg do track.m;
%criavideo = criavideodiff do track.m;
%avi = aviobj2 do track.m (o input e não o output nessa função!);
%wframe = working frame (double e em greyscale);
%frame = frame do track.m;
%INTENSIDADE = intervalo que dita o valor do V de HSV, ou seja, dita o limite para que as cores sejam mais 'intensas';
%V = Vrm do track.m;

function cor_atual = info_cores_frameAnterior(frame, Imback, V, nanimais, mascara, minpix, maxpix, tol, avi, criavideo, tipsubfundo ...
                                              , caixa, l, c ...
                                              , colorida, cor, tipfilt ...
                                              , INTENSIDADE)
                                          
        
    %variáveis que preciso para o funcionamento do código mas que não faz
    %sentido passar como parâmetros.
    dicax = -1;
    dicay = -1;
    
    pxant = zeros(1,nanimais);
    pyant = zeros(1,nanimais);
                              
    %VARIÁVEIS DE CONTROLE DA FUNÇÃO: o vetor de cores atuais e a media das cores num frame
    cor_atual = zeros(nanimais); %vetor com quantidade de espaços correspondentes as cores de cada animal.
    mediaFrameIndividual = 0; %(Em 1 peixe e muda em cada loop).

    %converte pra tons de cinza e double pra trabalhar
    if colorida || (cor == 1)
        wframe = double(frame);
    else
        wframe  = double(rgb2gray(frame));
    end


    %faz a diferenca so na area de interesse e extrai o centro de massas
    %das regioes (blobs) maiores que minpix
    [cx, cy, radius, boundingbox, ndetect, ~ , ~ , wframe_log] = extractnblobs(wframe, Imback, V, nanimais, mascara, minpix, maxpix, tol, avi, criavideo, tipsubfundo);

    %vetor que irá decorar cada animal que ja foi associado a um blob
    detectado = zeros(nanimais);

    if pxant(1) ~= 0 %global variable;

        if  tipfilt == 1
            %previsao do filtro de kalman
            for j=1:nanimais
                pdecorada = [pxant(j); pyant(j)];
                predita = A*[pdecorada;v(:,j)] + Bu;
                %garantir que esta dentro da imagem
                predita(1) = min(max(predita(1),1),c);
                predita(2) = min(max(predita(2),1),l);
                pxant(j) = predita(1);
                pyant(j) = predita(2);
                v(:,j) = predita(3:4);
            end
        end

    end

    %OLHAR POR PX E PY
    [ ~ , ~ , detectado, caixa] = associateeuclid(nanimais, ndetect, pxant, pyant, cx, cy, radius, boundingbox, detectado, dicax, dicay ...
                                                 ,caixa, l, c, frame);

    %aqui começa a parte que trata do cáculo das médias

    frameHSV = rgb2hsv(frame);  %converte o i-ésimo frame(frame atual) para HSV;

    %OBS: Somente conseguimos dizer que o k-ésimo elemento do loop é o k-ésimo peixe em todas as situações porque antes de
    %rodar esse loop, as funções extractnblobs() e associateeuclid() fora executadas!

    %percorrendo de k=1 até o numero de animais (podemos ter mais de um blob por frame)
    for k=1:1:nanimais %blob individual do frame

        %variáveis para o tratamento da descontinuidade das cores no sistema HSV.
        amostrando = 1; %flag que garante uma pequena amostragem dos píxeis
        conta_amostrando = 0;
        quad14 = 0;
        quad23 = 0;
        quad_usado = 0;

        sizeOfBlob = 0; %number of pixels/blob;

        %PERCORRENDO A BOUNDING BOX
        m = floor(caixa(k, 2))+1; %reiniciando a coordenada m
        while m <= floor(caixa(k, 2) + caixa(k,4))

            n = floor(caixa(k, 1)); %reiniciando a coordenada n
            while n <= floor(caixa(k, 1) + caixa(k,3))
                if(detectado(k))
                    %detectado(:) é a condição em 0's e 1's de ter um peixe ou não associado ao k-ésimo blob(?) (VEM DO ASSOCIATEEUCLID() )                    
                    if(wframe_log(m,n) == 1 &&  frameHSV(m,n,2) >= 0.5 && frameHSV(m,n,3) >= 0.15)
                        %Amostrar alguns pixels, utilizar uma flag para selecionar os pixels e contamos quantos pixels pertencem a cada quadrante
                        %Após isso definiremos o espaço onde vamos trabalhar e resetamos o rastreio com o quadrante predominante
                        %Transformação T[h] = h - 1 

                        if amostrando
                            conta_amostrando = conta_amostrando + 1;

                            if frameHSV(m,n,1) >= 0.25 && frameHSV(m,n,1) <= 0.75 %intervalo das cores
                                quad23 = quad23 + 1;    %dois quadrantes do lado esquerdo (tons de verde e azul)
                            else 
                                quad14 = quad14 + 1;    %dois quadrantes do lado direito (tons de vermelho e amarelo(?)
                            end

                            %definindo com que quadrante trabalhar e resetando a flag
                            if conta_amostrando > 50
                                amostrando = 0;

                                if quad23 > quad14
                                    quad_usado = 23;
                                else
                                    quad_usado = 14;
                                end
                                    %voltamos para a execução normal do código
                                    m = floor(caixa(k, 2));
                                    n = floor(caixa(k, 1));
                            end

                        else
                            pixel_hue = transformada_HSV( frameHSV(m,n,1), quad_usado);
                            
                            %se meu pixel for um NaN, ao somar a mediaFrameIndividual ele transformara o valor contido em NaN, que não é o que queremos
                            if ~(isnan(pixel_hue))
                                mediaFrameIndividual = mediaFrameIndividual + pixel_hue;
                            end
                            
                            sizeOfBlob = sizeOfBlob + 1;
                        end

                    end
                end

                n = n + 1; %incrementa a coordenada n

            end
            
            m = m + 1; %incrementa a coordenada m
        end

        %a média deve ser calculada depois de percorrer toda aquela bounding box para o k-ésimo animal
        mediaFrameIndividual =  mediaFrameIndividual/sizeOfBlob;
        cor_atual(k) = mediaFrameIndividual; % (media do k-ésimo animal no i-ésimo frame)
        
        %zerando as variáveis de controle
        mediaFrameIndividual = 0;
            
    end
        
    %tratamento final
    for k=1:1:nanimais
       if cor_atual(k)>=0.25 && cor_atual(k)<=0.75 && cor_atual(k)<0
          cor_atual(k) = cor_atual(k) + 1; 
       end
    end
    
    disp(['------------ H(peixe ',num2str(k = ', num2str(cor_atual(k))])

end


function H_novo = transformada_HSV(H, quadrante_usado)
    if quadrante_usado == 23
        H_novo = H;
    elseif quadrante_usado == 14
        if H >= 0.75
            H_novo = H - 1;
        else
            H_novo = H;       %se quadrante_usado == 14, então, aqui, necessariamente 0 <= H <= 0.25 (low-red)
        end
    end
end

